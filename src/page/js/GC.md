### 垃圾回收机制与常见的内存泄漏
> 了解垃圾回收要先了解内存分配，在js中，每个string、arr、obj都需要一定得内存，
>再给它们赋值时，在内存中给它们分配的一定得空间。不管有多大的空间，总有用完的一刻。
>所以出现了垃圾回收机制，将不用的变量，将其空间清除。那么浏览器是如何进行垃圾回收呢？ 

#### 标记清除: 
> js中分为全局变量，和局部变量。全局变量中的变量永远不会被回收（这就是慎用全局变量的原因）。 
>在局部环境中，进入局部环境给每个变量添加标记。环境结束后清除没有被引用的变量
```js
var a = 10; // 全局变量 （不会被回收）
function fn1() {
    var b = 10;
}
fn1(); // 运行结束后 b 会被回收
function fn2() {
    var c = 10;
    return function fn3 () {
        console.log(c);
    }
}
fn2()(); // c不会被回收
```

#### 引用计数(已废弃): 
> 声明变量并赋值后 引用次数加一； 
> 同一个值被赋予给另一个变量，引用次数加一； 
> 相反，这个变量引用其他值，引用次数减一；
> 当引用次数为0时，可以被回收
```js
function fn1() {
    var a = {}; +1 // 引用次数1
    var b = a;  +1 // 引用次数2
    a = 5; -1 // 引用次数1
    b = {} -1 // 引用次数0
}
fn1()
// IE7中循环引用会导致无法清除
function fn2() {
    var a = {} // a+1  引用次数1
    var b = { SEX: 'N'}; // b+1 引用次数1
    a.pro = b; // a+2   引用次数2
    b.proA = a; //b +1  引用次数2
}
fn2()
```

#### 垃圾回收机制什么时候触发
> 有一个比较经典的案例，IE6规定(256个变量、4096个对象、64k字符)是会触发
> 问题（如果系统一直有大于256个变量呢）好在IE7 改正了这一问题（内存占用超过85%触发）。
> 一般会根据不同浏览器会有不同垃圾回收周期，具体何时触发垃圾回收不清楚


#### v8 垃圾回收机制（尚未了解）